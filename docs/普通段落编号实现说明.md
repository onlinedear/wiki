# 普通段落编号实现说明

## 需求

在有序列表中，普通段落（非标题）的编号应该**按组独立计数**，每当遇到标题时重置计数器。

## 错误理解

❌ **错误1**：整个文档连续计数（1, 2, 3, 4, 5...）
❌ **错误2**：每个 `orderedList` 独立计数但不重置

## 正确实现

✅ **正确**：每组连续的普通段落独立计数，遇到标题时重置

### 示例

```
1. 标题A (H1)
1.1. 标题B (H2)
1.1.1. 标题C (H3)
1.1.2. 标题D (H3)
  1. 普通段落 ← 第一组开始
  2. 普通段落
1.1.3. 标题E (H3) ← 遇到标题，重置计数器
2. 标题F (H1)
  1. 普通段落 ← 第二组开始，重新从1计数
  2. 普通段落
  3. 普通段落
2.1. 标题G (H2) ← 遇到标题，重置计数器
3. 标题H (H1)
3.1. 标题I (H2)
  1. 普通段落 ← 第三组开始，重新从1计数
  2. 普通段落
  3. 普通段落
  4. 普通段落
```

## 实现代码

### 关键逻辑

```typescript
// 在每个 orderedList 内部
let plainParagraphCounter = 0;

node.forEach((listItem, offset) => {
  const firstChild = listItem.firstChild;
  
  // 如果是标题
  if (firstChild && firstChild.type.name === 'heading') {
    // 重置普通段落计数器
    plainParagraphCounter = 0;
    
    // 处理标题编号...
  }
  // 如果是普通段落
  else if (firstChild && firstChild.type.name === 'paragraph') {
    // 递增计数器
    plainParagraphCounter++;
    const currentNumber = plainParagraphCounter; // 立即捕获值
    
    // 创建编号 widget
    const widget = Decoration.widget(paragraphPos, () => {
      const span = document.createElement('span');
      span.textContent = `${currentNumber}. `;
      // ...
      return span;
    });
  }
});
```

### 关键点

1. **计数器位置**：`plainParagraphCounter` 在 `orderedList` 层级声明，每个列表独立
2. **重置时机**：遇到标题时执行 `plainParagraphCounter = 0`
3. **立即捕获**：使用 `const currentNumber = plainParagraphCounter` 避免闭包问题
4. **递增时机**：只在普通段落时执行 `plainParagraphCounter++`

## 文件位置

- 实现文件：`packages/editor-ext/src/lib/ordered-list/ordered-list.ts`
- CSS 文件：`apps/client/src/features/editor/styles/ordered-list.css`

## 注意事项

- 普通段落使用 JavaScript widget 显示编号，不使用 CSS `::before`
- CSS 只负责隐藏浏览器默认编号（`list-style-type: none`）
- 标题和普通段落的编号系统完全独立
