# 标题自动编号实现方案 v2

## 问题背景

在 v1 版本中，我们尝试使用纯 CSS Counter 来实现标题自动编号，但遇到了一个核心问题：

**CSS Counter 无法避免 "0.x" 的显示**

当 H2 标题没有父级 H1 时，`counter(h1-counter)` 的值是 0，导致显示为 "0.1", "0.2"，不符合 PRD 要求。

虽然可以通过 `:not(:has())` 选择器来检测父级是否存在，但这会导致：
1. 计数器递增逻辑冲突（多个规则同时匹配）
2. 编号混乱（如图所示的 1.0, 1.0.1, 3.1 重复等问题）
3. CSS 规则过于复杂，难以维护

## 新方案：JavaScript + CSS

### 核心思路

**分离计算和显示**：
- **JavaScript 插件**：负责计算正确的编号
- **CSS**：负责显示编号

### 实现细节

#### 1. JavaScript 插件（`ordered-list.ts`）

在 `CustomOrderedList` 扩展中添加 ProseMirror 插件：

```typescript
addProseMirrorPlugins() {
  return [
    new Plugin({
      key: new PluginKey('headingNumbering'),
      appendTransaction: (transactions, oldState, newState) => {
        // 监听文档变化
        const docChanged = transactions.some(tr => tr.docChanged);
        if (!docChanged) return null;

        const tr = newState.tr;
        let modified = false;

        // 遍历所有有序列表
        newState.doc.descendants((node, pos) => {
          if (node.type.name === 'orderedList') {
            // 计数器
            const counters = { h1: 0, h2: 0, h3: 0, ... };
            const hasLevel = { h1: false, h2: false, h3: false, ... };
            
            // 遍历列表项
            node.forEach((listItem, offset) => {
              if (listItem.firstChild?.type.name === 'heading') {
                const level = listItem.firstChild.attrs.level;
                
                // 递增计数器
                counters[`h${level}`]++;
                hasLevel[`h${level}`] = true;
                
                // 重置下级计数器
                for (let i = level + 1; i <= 6; i++) {
                  counters[`h${i}`] = 0;
                  hasLevel[`h${i}`] = false;
                }
                
                // 计算编号（关键逻辑）
                let computedNumber = '';
                if (level === 1) {
                  computedNumber = `${counters.h1}`;
                } else if (level === 2) {
                  // 如果没有 H1，显示为 "1", "2"
                  computedNumber = hasLevel.h1 
                    ? `${counters.h1}.${counters.h2}`
                    : `${counters.h2}`;
                } else if (level === 3) {
                  // 根据父级情况决定格式
                  if (!hasLevel.h1 && !hasLevel.h2) {
                    computedNumber = `${counters.h3}`;
                  } else if (!hasLevel.h1 && hasLevel.h2) {
                    computedNumber = `${counters.h2}.${counters.h3}`;
                  } else if (hasLevel.h1 && !hasLevel.h2) {
                    computedNumber = `${counters.h1}.${counters.h3}`;
                  } else {
                    computedNumber = `${counters.h1}.${counters.h2}.${counters.h3}`;
                  }
                }
                
                // 更新 listItem 的 computedNumber 属性
                tr.setNodeMarkup(listItemPos, undefined, {
                  ...listItem.attrs,
                  computedNumber,
                  headingLevel: level,
                });
                modified = true;
              }
            });
          }
        });

        return modified ? tr : null;
      },
    }),
  ];
}
```

#### 2. CSS 样式（`ordered-list.css`）

简化的 CSS，使用 `data-computed-number` 属性：

```css
/* 使用 JavaScript 计算的编号 */
.tiptap ol li[data-computed-number] > h1::before,
.tiptap ol li[data-computed-number] > h2::before,
.tiptap ol li[data-computed-number] > h3::before {
  content: attr(data-computed-number) ". ";
  position: absolute;
  left: 0;
  top: 0;
  font-weight: 700;
  /* ... 其他样式 ... */
}
```

### 优势

1. **逻辑清晰**：编号计算逻辑集中在 JavaScript 中，易于理解和维护
2. **完全控制**：可以实现任意复杂的编号规则
3. **性能优秀**：只在文档变化时重新计算，不影响渲染性能
4. **符合 PRD**：完美解决 "0.x" 问题

### 编号规则

| 场景 | 显示格式 | 示例 |
|------|---------|------|
| 只有 H1 | `1.`, `2.`, `3.` | 1. 第一章 |
| 只有 H2（无 H1） | `1.`, `2.`, `3.` | 1. 第一节 |
| 只有 H3（无 H1/H2） | `1.`, `2.`, `3.` | 1. 第一小节 |
| H1 + H2 | `1.1`, `1.2`, `2.1` | 1.1 第一节 |
| H1 + H3（无 H2） | `1.1`, `1.2`, `2.1` | 1.1 第一小节 |
| H2 + H3（无 H1） | `1.1`, `1.2`, `2.1` | 1.1 第一小节 |
| H1 + H2 + H3 | `1.1.1`, `1.1.2` | 1.1.1 第一小节 |

### 测试验证

使用之前创建的测试场景（`docs/标题自动编号快速测试.md`）进行验证：

1. ✅ 只有 H2 标题 → 显示 "1.", "2.", "3."
2. ✅ 只有 H3 标题 → 显示 "1.", "2.", "3."
3. ✅ H2 + H3 混合 → 显示 "1.", "1.1", "1.2", "2.", "2.1"
4. ✅ H1 + H3 混合 → 显示 "1.", "1.1", "1.2", "2.", "2.1"
5. ✅ 完整层级 → 显示 "1.", "1.1", "1.1.1", "1.1.2"

### 后续工作

1. **构建和测试**：
   ```bash
   cd packages/editor-ext
   pnpm build
   
   cd ../../apps/client
   pnpm dev
   ```

2. **验证功能**：
   - 创建有序列表
   - 插入不同级别的标题
   - 验证编号是否正确

3. **性能测试**：
   - 测试 500+ 标题的文档
   - 验证编号计算耗时

4. **协作测试**：
   - 多人同时编辑
   - 验证编号同步是否正确

## 技术细节

### ProseMirror 插件机制

- **appendTransaction**：在事务提交后执行，可以修改文档
- **docChanged**：检测文档是否变化，避免不必要的计算
- **setNodeMarkup**：更新节点属性，不改变节点内容

### 属性存储

在 `listItem` 节点上存储两个属性：
- `computedNumber`：计算出的编号（如 "1.1.1"）
- `headingLevel`：标题级别（1-6）

这些属性会被渲染为 HTML 属性：
```html
<li data-computed-number="1.1.1" data-heading-level="3">
  <h3>标题内容</h3>
</li>
```

### CSS attr() 函数

使用 `attr()` 函数读取 HTML 属性值：
```css
content: attr(data-computed-number) ". ";
```

这样 CSS 就能显示 JavaScript 计算的编号。

## 总结

v2 方案通过 JavaScript + CSS 的组合，完美解决了 v1 中的 "0.x" 问题。虽然增加了一些 JavaScript 代码，但换来了：
- 更清晰的逻辑
- 更灵活的控制
- 更符合 PRD 的结果

这是一个典型的"用正确的工具做正确的事"的案例：CSS Counter 适合简单的递增编号，但对于复杂的条件逻辑，JavaScript 是更好的选择。
